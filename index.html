<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smartboard Whiteboard</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            font-family: Arial, sans-serif;
            user-select: none;
            background-color: #f0f0f0;
        }

        /* 1. Full Screen Canvas */
        #whiteboard {
            display: block;
            background-color: white; /* Default background */
            cursor: crosshair;
        }

        /* 2. Tool Control Panel */
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        .tool-button, .slide-button {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background-color: #eee;
            transition: background-color 0.2s, transform 0.1s;
        }

        .tool-button:hover, .slide-button:hover {
            background-color: #ddd;
        }

        .tool-button.active {
            background-color: #007bff;
            color: white;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
        }

        /* Input Styles */
        #pen-color, #bg-color {
            width: 35px;
            height: 35px;
            border: none;
            padding: 0;
            border-radius: 6px;
            cursor: pointer;
        }

        input[type="range"] {
            width: 80px;
            margin: 0 5px;
        }

        /* Slide Controls */
        #slide-controls {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        #slide-count {
            padding: 8px 12px;
            background-color: #eee;
            border-radius: 6px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <canvas id="whiteboard"></canvas>

    <div id="controls">
        <button class="tool-button active" data-tool="pen">‚úèÔ∏è Normal Pen</button>
        <button class="tool-button" data-tool="fountain">üñãÔ∏è Fountain Pen</button>
        <button class="tool-button" data-tool="brush">üé® Brush Pen</button>
        <button class="tool-button" data-tool="shape">üìê Shape Tool</button>
        <button class="tool-button" data-tool="text">‚úçÔ∏è Text Tool</button>
        <button class="tool-button" data-tool="eraser">üî™ Eraser</button>

        <label for="line-width">Width:</label>
        <input type="range" id="line-width" min="1" max="50" value="5">

        <label for="pen-color">Pen:</label>
        <input type="color" id="pen-color" value="#000000">
        <label for="bg-color">BG:</label>
        <input type="color" id="bg-color" value="#FFFFFF">

        <button class="tool-button" id="save-btn">üíæ Save PNG</button>
    </div>

    <div id="slide-controls">
        <button class="slide-button" id="prev-slide">‚Üê Prev</button>
        <span id="slide-count">Slide 1 of 1</span>
        <button class="slide-button" id="next-slide">Next ‚Üí</button>
        <button class="slide-button" id="add-slide">+ New Slide</button>
    </div>

    <script>
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const controls = document.getElementById('controls');
        
        let isDrawing = false;
        let currentTool = 'pen';
        let currentStroke = [];
        let startX, startY;

        // --- State Management (Slides) ---
        let slides = [{
            backgroundColor: '#FFFFFF',
            drawingObjects: [] // Stores all strokes/shapes for the slide
        }];
        let currentSlideIndex = 0;

        // --- Settings ---
        let penColor = document.getElementById('pen-color').value;
        let lineWidth = parseInt(document.getElementById('line-width').value);

        // --- Full Screen Setup and Resizing ---
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            redrawCanvas(); // Redraw content when size changes
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- Core Drawing Logic ---
        
        // Redraws the current slide content from the 'drawingObjects' array
        function redrawCanvas() {
            const slide = slides[currentSlideIndex];
            
            // 1. Set Background
            canvas.style.backgroundColor = slide.backgroundColor;
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas area
            
            // 2. Redraw all stored objects
            slide.drawingObjects.forEach(obj => {
                ctx.strokeStyle = obj.color;
                ctx.lineWidth = obj.width;
                ctx.lineCap = obj.cap || 'round';
                ctx.lineJoin = 'round';
                
                if (obj.type === 'stroke') {
                    // Draw a freehand stroke
                    ctx.beginPath();
                    for (let i = 0; i < obj.points.length; i++) {
                        const p = obj.points[i];
                        if (i === 0) {
                            ctx.moveTo(p.x, p.y);
                        } else {
                            ctx.lineTo(p.x, p.y);
                        }
                    }
                    ctx.stroke();

                } else if (obj.type === 'shape') {
                    // Draw a perfect shape (Rectangle, Circle, etc.)
                    ctx.beginPath();
                    if (obj.shapeType === 'rect') {
                        ctx.rect(obj.x, obj.y, obj.width, obj.height);
                    } else if (obj.shapeType === 'circle') {
                        // Simple circle using distance as radius
                        const radius = Math.sqrt(Math.pow(obj.width, 2) + Math.pow(obj.height, 2));
                        ctx.arc(obj.x, obj.y, radius, 0, 2 * Math.PI);
                    } else if (obj.shapeType === 'line') {
                        ctx.moveTo(obj.x, obj.y);
                        ctx.lineTo(obj.x + obj.width, obj.y + obj.height);
                    }
                    ctx.stroke();

                } else if (obj.type === 'text') {
                    // PLACEHOLDER: Draw recognized text
                    ctx.fillStyle = obj.color;
                    ctx.font = `${obj.width * 4}px Arial`; // Use line width for text size
                    ctx.fillText(obj.text, obj.x, obj.y);
                }
            });
        }
        
        // --- Event Handlers (Mouse/Touch) ---

        function startDrawing(e) {
            // Ignore if event is over the controls panel
            if (e.target.closest('#controls') || e.target.closest('#slide-controls')) return;

            isDrawing = true;
            const x = e.clientX || e.touches[0].clientX;
            const y = e.clientY || e.touches[0].clientY;
            
            startX = x;
            startY = y;
            currentStroke = [{ x, y }];

            // Start path for immediate visual feedback
            ctx.beginPath();
            ctx.moveTo(x, y);

            if (currentTool === 'text') {
                // For the Text Tool, we immediately finalize a text object on click
                const slide = slides[currentSlideIndex];
                slide.drawingObjects.push({
                    type: 'text',
                    text: 'Type Text Here', // Placeholder, in a real app this would prompt for input
                    x: x,
                    y: y,
                    color: penColor,
                    width: lineWidth
                });
                redrawCanvas();
                isDrawing = false; // Stop drawing immediately
            }
        }

        function draw(e) {
            if (!isDrawing) return;

            const x = e.clientX || e.touches[0].clientX;
            const y = e.clientY || e.touches[0].clientY;

            // Add point to current stroke
            currentStroke.push({ x, y });

            // Set drawing style based on tool
            ctx.strokeStyle = (currentTool === 'eraser') ? slides[currentSlideIndex].backgroundColor : penColor;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalCompositeOperation = (currentTool === 'eraser') ? 'destination-out' : 'source-over';
            
            if (currentTool === 'pen' || currentTool === 'eraser') {
                ctx.lineTo(x, y);
                ctx.stroke();

            } else if (currentTool === 'fountain' || currentTool === 'brush') {
                // Simple pressure simulation (based on distance from last point)
                const lastPoint = currentStroke[currentStroke.length - 2];
                const distance = Math.sqrt(Math.pow(x - lastPoint.x, 2) + Math.pow(y - lastPoint.y, 2));
                const dynamicWidth = Math.max(1, lineWidth - distance * 0.5); // Thicker line if drawn slower
                
                ctx.lineWidth = dynamicWidth;
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.beginPath(); // New path segment for continuous line
                ctx.moveTo(x, y); // Move to current point for next segment

            } else if (currentTool === 'shape') {
                // Draw a temporary shape overlay
                redrawCanvas(); // Redraw previous content
                ctx.strokeStyle = penColor;
                ctx.lineWidth = lineWidth;
                ctx.setLineDash([]); // Ensure no dotted lines
                
                const width = x - startX;
                const height = y - startY;

                ctx.beginPath();
                // Draw a perfect rectangle
                ctx.rect(startX, startY, width, height);
                ctx.stroke();
            }
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            isDrawing = false;
            
            const slide = slides[currentSlideIndex];
            
            // Finalize drawing based on the tool
            if (currentTool === 'pen' || currentTool === 'fountain' || currentTool === 'brush') {
                // Save the freehand stroke (even if it was dynamically rendered)
                slide.drawingObjects.push({
                    type: 'stroke',
                    points: currentStroke,
                    color: penColor,
                    width: lineWidth,
                    cap: 'round'
                });
            } else if (currentTool === 'eraser') {
                // NOTE: Eraser on canvas removes pixels, but doesn't remove stored objects.
                // For true object erasure, you'd need an advanced collision detection system here.
                // For now, it's a 'pixel' eraser.
            } else if (currentTool === 'shape') {
                // Save the final shape object
                const finalX = e.clientX || e.changedTouches[0].clientX;
                const finalY = e.clientY || e.changedTouches[0].clientY;
                const width = finalX - startX;
                const height = finalY - startY;
                
                slide.drawingObjects.push({
                    type: 'shape',
                    shapeType: 'rect', // Default to rectangle
                    x: startX,
                    y: startY,
                    width: width,
                    height: height,
                    color: penColor,
                    width: lineWidth
                });
            }
            
            // Reset composite operation after drawing/erasing
            ctx.globalCompositeOperation = 'source-over';
            currentStroke = [];
            redrawCanvas();
        }

        // --- Event Listeners for Drawing ---
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing); // Stop if mouse leaves canvas

        // Touch support for smartboards
        canvas.addEventListener('touchstart', (e) => startDrawing(e));
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling on touch move
            draw(e);
        });
        canvas.addEventListener('touchend', stopDrawing);

        // --- UI Control Handlers ---

        // Tool Selection
        controls.addEventListener('click', (e) => {
            if (e.target.classList.contains('tool-button')) {
                // Update active class
                document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');

                // Update current tool
                const tool = e.target.getAttribute('data-tool');
                if (tool) {
                    currentTool = tool;
                    canvas.style.cursor = (currentTool === 'eraser') ? 'cell' : 'crosshair';
                }
            }
        });

        // Width Range
        document.getElementById('line-width').addEventListener('input', (e) => {
            lineWidth = parseInt(e.target.value);
        });

        // Pen Color
        document.getElementById('pen-color').addEventListener('input', (e) => {
            penColor = e.target.value;
        });

        // Background Color
        document.getElementById('bg-color').addEventListener('input', (e) => {
            slides[currentSlideIndex].backgroundColor = e.target.value;
            redrawCanvas();
        });

        // --- Slide Management Functions ---
        
        function updateSlideCount() {
            document.getElementById('slide-count').textContent = `Slide ${currentSlideIndex + 1} of ${slides.length}`;
            // Update BG Color picker to reflect current slide's BG
            document.getElementById('bg-color').value = slides[currentSlideIndex].backgroundColor;
        }

        document.getElementById('add-slide').addEventListener('click', () => {
            slides.push({
                backgroundColor: '#FFFFFF',
                drawingObjects: []
            });
            currentSlideIndex = slides.length - 1;
            redrawCanvas();
            updateSlideCount();
        });

        document.getElementById('prev-slide').addEventListener('click', () => {
            if (currentSlideIndex > 0) {
                currentSlideIndex--;
                redrawCanvas();
                updateSlideCount();
            }
        });

        document.getElementById('next-slide').addEventListener('click', () => {
            if (currentSlideIndex < slides.length - 1) {
                currentSlideIndex++;
                redrawCanvas();
                updateSlideCount();
            }
        });

        // --- Save Function ---
        document.getElementById('save-btn').addEventListener('click', () => {
            // Create a temporary canvas to include the background color
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            // Draw background
            tempCtx.fillStyle = slides[currentSlideIndex].backgroundColor;
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Draw the current canvas content (only the strokes)
            tempCtx.drawImage(canvas, 0, 0);

            // Trigger download
            const link = document.createElement('a');
            link.download = `whiteboard_slide_${currentSlideIndex + 1}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        });

        // Initial setup
        updateSlideCount();
        redrawCanvas();
    </script>

</body>
</html>
